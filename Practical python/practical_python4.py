#리스트 컴프리핸션
a=[1,2,3,4,5]
b=[2*x for x in a] #이와같이 리스트를 생성할 수 있다.
#b의 값은 2,4,6,8,10

names=['Elwood','Bak']
l_names=[names.lower() for name in names]
print(l_names) #elwood bak

#객체

#1)할당
a=value #변수할당
s[n] =value #리스트에 할당
s.append(value) #리스트에 추가
d['key']=value #딕셔너리에 key, value쌍 추가

'''
이때 할당될 값의 사본을 생성하는 것이 아니라
래퍼런스 복사(혹은 포인터 복사)일 뿐이다.
'''

a=[1,2,3]
b=a
c=[a,b]

'''
리스트는 [1,2,3] 한개
이를 참조(reference)하는 a,b,c(c가 두개를 참조) 총 4개이다
이는 아래를 보면 명확히 알 수 있는데 사본이 아닌 래퍼런스 복사이므로
하나를 수정하면 모든 변수가 영향을 받는 것을 확인할 수 있다.
>>> a.append(999)
>>> a
[1,2,3,999]
>>> b
[1,2,3,999]
>>> c
[[1,2,3,999], [1,2,3,999]]
'''

#2)재할당 --> 값을 재할당한다고 해서, 이전 값에서 사용한 메모리를 덮어쓰는 것이 절대 아니다
a=[1,2,3]
b=a
a=[4,5,6]

print(a) #[4,5,6] --> 왜냐면 새로운 리스트 [4,5,6]을 가리키도록 한 것이므로!
print(b) #[1,2,3] 원래 값은 그대로 유지

'''
>>> a = [2,3,[100,101],4]
>>> b = list(a) # 사본을 만듦
>>> a is b
False
그러나 중간의 리스트는 공유되고 있는데

>>> a[2].append(102)
>>> b[2]
[100,101,102]
이처럼 중간의 리스트 안의 요소를 변경하면 공유하고 있는
다른 변수에서도 변경이 반영된

이런 경우를 막고 싶다면 deepcopy를 사용하면 된다
>>> a = [2,3,[100,101],4]
>>> import copy
>>> b = copy.deepcopy(a)
>>> a[2].append(102)
>>> b[2]
[100,101]
>>> a[2] is b[2]
False
>>>
'''

